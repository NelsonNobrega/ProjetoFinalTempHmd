/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Implementation of an immutable SortedMap using a Left-leaning
 * Red-Black Tree, adapted from the implementation in Mugs
 * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen
 * (mads379\@gmail.com).
 *
 * Original paper on Left-leaning Red-Black Trees:
 *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
 *
 * Invariant 1: No red node has a red child
 * Invariant 2: Every leaf path has the same number of black nodes
 * Invariant 3: Only the left child can be red (left leaning)
 */
export declare type Comparator<K> = (key1: K, key2: K) => number;
/**
 * An iterator over an LLRBNode.
 */
export declare class SortedMapIterator<K, V, T> {
    private isReverse_;
    private resultGenerator_;
    private nodeStack_;
    /**
     * @param node - Node to iterate.
     * @param isReverse_ - Whether or not to iterate in reverse
     */
    constructor(node: LLRBNode<K, V> | LLRBEmptyNode<K, V>, startKey: K | null, comparator: Comparator<K>, isReverse_: boolean, resultGenerator_?: ((k: K, v: V) => T) | null);
    getNext(): T;
    hasNext(): boolean;
    peek(): T;
}
/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
export declare class LLRBNode<K, V> {
    key: K;
    value: V;
    color: boolean;
    left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    /**
     * @param key - Key associated with this node.
     * @param value - Value associated with this node.
     * @param color - Whether this node is red.
     * @param left - Left child.
     * @param right - Right child.
     */
    constructor(key: K, value: V, color: boolean | null, left?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null);
    static RED: boolean;
    static BLACK: boolean;
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param key - New key for the node, or null.
     * @param value - New value for the node, or null.
     * @param color - New color for the node, or null.
     * @param left - New left child for the node, or null.
     * @param right - New right child for the node, or null.
     * @returns The node copy.
     */
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBNode<K, V>;
    /**
     * @returns The total number of nodes in the tree.
     */
    count(): number;
    /**
     * @returns True if the tree is empty.
     */
    isEmpty(): boolean;
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    inorderTraversal(action: (k: K, v: V) => unknown): boolean;
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    /**
     * @returns The minimum node in the tree.
     */
    private min_;
    /**
     * @returns The maximum key in the tree.
     */
    minKey(): K;
    /**
     * @returns The maximum key in the tree.
     */
    maxKey(): K;
    /**
     * @param key - Key to insert.
     * @param value - Value to insert.
     * @param comparator - Comparator.
     * @returns New tree, with the key/value added.
     */
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    /**
     * @returns New tree, with the minimum key removed.
     */
    private removeMin_;
    /**
     * @param key - The key of the item to remove.
     * @param comparator - Comparator.
     * @returns New tree, with the specified item removed.
     */
    remove(key: K, comparator: Comparator<K>): LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    /**
     * @returns Whether this is a RED node.
     */
    isRed_(): boolean;
    /**
     * @returns New tree after performing any needed rotations.
     */
    private fixUp_;
    /**
     * @returns New tree, after moveRedLeft.
     */
    private moveRedLeft_;
    /**
     * @returns New tree, after moveRedRight.
     */
    private moveRedRight_;
    /**
     * @returns New tree, after rotateLeft.
     */
    private rotateLeft_;
    /**
     * @returns New tree, after rotateRight.
     */
    private rotateRight_;
    /**
     * @returns Newt ree, after colorFlip.
     */
    private colorFlip_;
    /**
     * For testing.
     *
     * @returns True if all is well.
     */
    private checkMaxDepth_;
    check_(): number;
}
/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
export declare class LLRBEmptyNode<K, V> {
    key: K;
    value: V;
    left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    color: boolean;
    /**
     * Returns a copy of the current node.
     *
     * @returns The node copy.
     */
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBEmptyNode<K, V>;
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @param comparator - Comparator.
     * @returns New tree, with item added.
     */
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param key - The key to remove.
     * @param comparator - Comparator.
     * @returns New tree, with item removed.
     */
    remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V>;
    /**
     * @returns The total number of nodes in the tree.
     */
    count(): number;
    /**
     * @returns True if the tree is empty.
     */
    isEmpty(): boolean;
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    inorderTraversal(action: (k: K, v: V) => unknown): boolean;
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    minKey(): null;
    maxKey(): null;
    check_(): number;
    /**
     * @returns Whether this node is red.
     */
    isRed_(): boolean;
}
/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
export declare class SortedMap<K, V> {
    private comparator_;
    private root_;
    /**
     * Always use the same empty nod†~~„:H¨!(_ñŒ¢é°õ›7»ÅÖôp×ºûõ4­AĞ%÷MŸ$Èî®}ÏÁèòîæ¯s…ü ¡3PF`Áõök¨5ã•Ù^úæ˜*Äk8oèì¢KxA­&V†ê+IY=R;Gn‰ÙLs„õüõæ§F°¾ á=>2t¾<ôŞ>ëŠoºâa~^˜SHsÏf^ÜÆZaÉâaâ€va)/rÁ¥L¬œoGŸÿåZšıˆ³;›9ÿbKŸ²']hSëo_àfYãTk8Ã)C&L´{ªEÜ‹•.T¹E_!é¡ßRÜÎ¦”=ò5lGğ™;z‹İB#Î"Üb´#X02uÚ³;›gì "ÅeLâ=³`˜R"›J5ÌĞû9ß™UÖ°ıÎdLî¢ì¶vo‹;"_­ÇÁ2ÛKÕ2É736Âëjö @“ıOÏLõrCëÕ‹{8ÃZFÙÛ¡·-¥Zî;[uø;–N,¿‹ı!?{óüê‡óc%V¾¢Ç!ˆJÇ-^çqJÇKæooCìbÙÓ<3½à,tãkb.ßÉ*—	ße.é¥DpÈ%ôµò’¯€ºu_›||VE¿©Ø4p‚½Öİ-u¸©ªúx
õ.¶Ûì«ëÀåÙÁ6Ê]Ì>·é0!„úöÍšiærØïı’¡²;ÛÜ$‚¾Wäíè{í@×òÒ¬h»ˆĞs|›HÎ="ñÊ`”§VzİfE5¯[íõcİ"zf’çÔÑÓğºı?ÓS2Ä*—Ãåâ JéÕÈFzz®òfõ½^šÓBärå&h©¾ŞQŞSáA•n²­üU2V‰[³–—ÜøbÃ	zt¬~“¡ëmâÅvU.1û
áÉ·‘Ä!V€&?f-´‡/ åagËİÒÈÊS˜Ïâ\’.1eã†GéC¸ó!ø•nç‚­rëÿHğ&X„2AYƒ`)ğƒtuã…¬Mò."-H‹DÒz¥rt‰î+`{Š…ÔH1gÈŞ©&€¬MòìŒ×U‘ ÄUòŞáh&gmÂ\¡=*±1£dY¡ªAq‚<›ä’¡MdEO^ÿOÖmÊÁºæB£:rÁg:/rm#”ÂòVkjË ªì&Õ”¨4ñ!‘¥Œşï÷±ß§ş«’c6…<×…CQBc6)†ögRãUÅ®½Í‘µ™Ñw­ò²¡xóÙë6T: qÊ¨¿Q«µ|õ)™+`|q_s%óÚ#ê–sqÈL_İß¸¼*Æ/»LŠr~‚y†l¼,›‰C6šg“ù5Øä02]â¬›Xe7’¹°•ÅÉ]‡²÷»5Ä=0”e¤~»AĞË‡ØLóÖ‹r*RÜË€b
OÂ²¼53éßY,ÖbÀú§šòÉÍòÚ&ªk_ÔÔZmÜ5]§×BH#U¤¯qYDŒ¬‚Iy;ÿJ@–UEšm¤î©ÁŸ´ŸÚ"OÖõŞfÖyš_bÚûNŞ:4¨]ÓÀ¬E6èïˆ~ƒS=¹ÍÃÁ f­‰Pı®;&O›8şñ¤gÇ;é»?3ñÁˆIÜs–é™dœ¹wç»¥éMx¥<×6½ó-˜ÎJäıÔ¦ Şd1í oï>”îµŠä¸…ß¥³óİå™dÇLl¹—ype¢ËŸ¦¶	¥}tª/=—©AìWvw†]¬&qc’ºĞ¼Úhï¸%ïJ4`]Â÷Ì*£÷«ÈØÓ·„ã¶lï|tÕ…ì3·â[.gHĞQ¬›ÎÍ‘ˆp²ÉTÀ‰&¥Ì¦Dl	z¢'9„Rô£vğë`ò‰¡ŸŒ¾9+u44¯ïPóºúz.†ZXY&Ùr#®kBò™µZKÑ„õÀhi¹ozÀæŞºâD_ÙÈ{`ŞW†û¿gş³7;Jû'²‘&½EÂ<èÀ¬¨•;mT&€P\08æo Ï|èÇù`dc"¬ıåW nÛ³7ãkë1ùs#ÜòoœRM İ@.§rÓí_v‘ê¿¤Kr=×Ó%æAa2QíIÇÏõä=PAƒßÆòËÛÌzò»·y~ŸC)4Ó×ï¼kyª]ö.Ì:Tp¢í!OÂ~$8‹DçÛbÖZèw¢s6ÿ<ZÇåÔ6¨~‘P;è	í@¹Ä”í`FÉJ¤ä®æ”Ü…”Äkç£ôşVºÚåiš¸­Ù4±3¶qÖy–‡“q½âA±_{æ ?²Ï@M÷`5·ÕV+´\&;|»Méö	ígü"÷`ÙŒ“»²ÀTÌÏ"w ¯/±òå¶,ŒB’-Ğ,•z¹rÉMš«éüñ
{ô¢BõZ©osÛğš+z`Ï-øÑcæ;nrú÷äû—@˜œÎY¬½Vr8¬h¥z8Å­ûó´“ß.wp«¾14 áûWìÂ ›KŒ†qOyl™ÁÜ™ù+ "?Bó›âÖy×„ßÜÒİô¤0Ô"€ÉOÅ\`n|)ŒüÙ@r9'Bî#R0º·n¢Å€ÙèÏZ1æª ‡/zä$óR¢B‰sÚ@5¿S3©HäNæ¶‘(ÈáMtäç­eMúĞzre£ŸÛêZÉ¿yĞ·Hïº	yX1`±.şWÈ­–r4àÿPõQùd»Ïœ’•¼Úî¥©W'ùM\îgä¤¶LòÕÂÇƒdPG¢qïƒ‚Ç¬Çİ ‘“
x|´ÍNo$r9ãT‡³p$T!ÂšcÙ#>7•¼zfâœ¹‰Ô·]¦oåƒØKRĞ,U‰s9£É2>9äWr›Îò½!©ùÛéƒƒÔŸ„Hy_½ÿÄå¤R.¯­ÔKÍ7ßâIğqÀng»DIv³‡¨å3nòÔn&9béã<’31CH¿+?Ü¦z“2g8å:`ªú>—h¶JS+Iz? „ñÊİÔ–ŒÈÍÉÜö>± ÏHÎÿ*³ğ¬)†¨fÓ„Ì>`¶ÚhxYhÕN›‰Ë±Db~¨Î^jØsgª“_>äK™•a Xk@­7 18«a~hÉÑˆ„äv ÍÚK\?ö7\ËrLîãMt½¨JMP®[=«UŠ­y²‹¤¬JŒËYkÒ…Í‹ñİ×ÚBØØHôÆeîäD½«u ¨‹hò„´ÚÀêÀ¤‰æcÇ#È»½’ì(ª²İµw¯~|-Š²=|)Níü%DNVÛaÀLWÊ«xÖhüßÑú9	G}NJhgo"¢<
¢‘ÎCåıd‹lîŒıVÅ× o9Ø<Şş¿éÂ!NùHóŸ‡2})ƒVÅ&Ó¥8µÍÇ;—8oªœ7 %1o²+0€Ö¦ä bş×¨2ÀF0™õ$œ¹*µw¤›ñõtÏ&|9!åv´´ÄÔfÅK–ôÄĞyyÆ ’(X.§±‘â¸åÈïœÕù6{4v,UI%ªí	Å˜ı¶ÌÒuj.É‰Ø’†'{"´ÛÚ¿½0Àá;ß×ákLœ1ôİfL0Ê›Êa¦!uX¸Ê‚ÆĞ{gzóW\´6ŸJ`÷[Ä¿#xnCÉôİâ=Ö€Êäá8®!hyãDi69¯§G¿ˆÂÇ¹¨?Q™©SùMFåc´ç`Í#±”°ê
–{Fy1w.±í'‹ ìkw¨Çå‚òf$9…¶%PùÉP¾2+¨£GRy*ô=¿G‡¾±_ÑqHõ;¿{…¾q>¥t}—ã÷­¡oÜŒ ´}÷ÁïkaşhÍûÇA:ç–{‰ª5»mÎÑü7»…É¶ìVóg&FxmtèÍ`×3kÿîr¼ŸîgH¡Ú’²9İ/=„V¹›šk”0Âª#³|Ó%tPHÌ´
å{÷—¾ˆÌÎ Ji‹ĞLÄìÚòÌ”R{ô
6ÙÌ¾’dßzİMæÙ òŞ@¦‹d™™v~°…÷íğ< öSç,r—ş—ÙOcÄ´$,6²!ÊZhÔbZ,|*+ 3ş