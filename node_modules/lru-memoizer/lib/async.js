"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncMemoizer = void 0;
var lru_cache_1 = __importDefault(require("lru-cache"));
var events_1 = require("events");
var lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
var freeze_1 = require("./freeze");
var sync_1 = require("./sync");
function asyncMemoizer(options) {
    var cache = new lru_cache_1.default(options);
    var load = options.load;
    var hash = options.hash;
    var bypass = options.bypass;
    var itemMaxAge = options.itemMaxAge;
    var freeze = options.freeze;
    var clone = options.clone;
    var queueMaxAge = options.queueMaxAge || 1000;
    var loading = new Map();
    var emitter = new events_1.EventEmitter();
    var memoizerMethods = Object.assign({
        del: del,
        reset: function () { return cache.reset(); },
        keys: cache.keys.bind(cache),
        on: emitter.on.bind(emitter),
        once: emitter.once.bind(emitter)
    }, options);
    if (options.disable) {
        return Object.assign(load, memoizerMethods);
    }
    function del() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var key = hash.apply(void 0, __spread(args));
        cache.del(key);
    }
    function add(key, parameters, result) {
        if (freeze) {
            result.forEach(freeze_1.deepFreeze);
        }
        if (itemMaxAge) {
            cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));
        }
        else {
            cache.set(key, result);
        }
    }
    function runCallbacks(callbacks, args) {
        var e_1, _a;
        try {
            for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
                var callback = callbacks_1_1.value;
                // Simulate async call when returning from cache
                // and yield between callback resolution
                if (clone) {
                    setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));
                }
                else {
                    setImmediate.apply(void 0, __spread([callback], args));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    function emit(event) {
        var parameters = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            parameters[_i - 1] = arguments[_i];
        }
        emitter.emit.apply(emitter, __spread([event], parameters));
    }
    function memoizedFunction() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var parameters = args.slice(0, -1);
        var callback = args.slice(-1).pop();
        var key;
        if (bypass && bypass.apply(void 0, __spread(parameters))) {
            emit.apply(void 0, __spread(['miss'], parameters));
            return load.apply(void 0, __spread(args));
        }
        if (parameters.length === 0 && !hash) {
            //the load function only receives callback.
            key = '_';
        }
        else {
            key = hash.apply(void 0, __spread(parameters));
        }
        var fromCache = cache.get(key);
        if (fromCache) {
            emit.apply(void 0, __spread(['hit'], parameters));
            // found, invoke callback
            return runCallbacks([callback], [null].concat(fromCache));
        }
        var pendingLoad = loading.get(key);
        if (pendingLoad && pendingLoad.expiresAt > Date.now()) {
            // request already in progress, queue and return
            pendingLoad.queue.push(callback);
            emit.apply(void 0, __spread(['queue'], parameters));
            return;
        }
        emit.apply(void 0, __spread(['miss'], parameters));
        var started = Date.now();
        // no pending request or not resolved before expiration
        // create a new queue and invoke load
        var queue = [callback];
        loading.set(key, {
            queue: queue,
            expiresAt: started + queueMaxAge
        });
        var loadHandler = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var err = args[0];
            if (!err) {
                add(key, parameters, args.slice(1));
            }
            // this can potentially delete a different queue than `queue` if
            // this callback was called after expiration.
            // that will only cause a new call to be performed and a new queue to be
            // created
            loading.delete(key);
            emit.apply(void 0, __spread(['loaded', Date.now() - started], parameters));
            runCallbacks(queue, args);
        };
        load.apply(void 0, __spread(parameters, [loadHandler]));
    }
    ;
    return Object.assign(memoizedFunction, memoizerMethods);
}
exports.asyncMemoizer = asyncMemoizer;
asyncMemoizer.sync = sync_1.syncMemoizer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN5bmMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvYXN5bmMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHdEQUE0QjtBQUM1QixpQ0FBc0M7QUFDdEMsc0VBQXlDO0FBQ3pDLG1DQUFzQztBQUN0QywrQkFBc0M7QUE2R3RDLFNBQVMsYUFBYSxDQUNwQixPQUF3QjtJQUV4QixJQUFNLEtBQUssR0FBUSxJQUFJLG1CQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDcEMsSUFBTSxJQUFJLEdBQVMsT0FBTyxDQUFDLElBQUksQ0FBQztJQUNoQyxJQUFNLElBQUksR0FBUyxPQUFPLENBQUMsSUFBSSxDQUFDO0lBQ2hDLElBQU0sTUFBTSxHQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUM7SUFDbEMsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQztJQUN0QyxJQUFNLE1BQU0sR0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDO0lBQ2xDLElBQU0sS0FBSyxHQUFRLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDakMsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUM7SUFDaEQsSUFBTSxPQUFPLEdBQU0sSUFBSSxHQUFHLEVBQXVCLENBQUM7SUFDbEQsSUFBTSxPQUFPLEdBQU0sSUFBSSxxQkFBWSxFQUFFLENBQUM7SUFFdEMsSUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNwQyxHQUFHLEtBQUE7UUFDSCxLQUFLLEVBQUUsY0FBTSxPQUFBLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBYixDQUFhO1FBQzFCLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDNUIsRUFBRSxFQUFFLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUM1QixJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0tBQ2pDLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFWixJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUU7UUFDbkIsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztLQUM3QztJQUVELFNBQVMsR0FBRztRQUFDLGNBQWM7YUFBZCxVQUFjLEVBQWQscUJBQWMsRUFBZCxJQUFjO1lBQWQn d o w s I n k W o r k s p a c e       Øÿÿÿvk	   €         highrange       àÿÿÿvk   €          lowrangeØÿÿÿvk   €         mergealgorithm  Øÿÿÿvk
   €         policytype      àÿÿÿvk   €         value   èÿÿÿlh  ©Ú É¸.À«Ú 'z?¬˜ÿÿÿnk  ¡OUÕÞ¬Õ    ¸¨Ú         ÿÿÿÿÿÿÿÿ   H¬Ú ™µ ÿÿÿÿ           `          AllowWindowsInkWorkspaceàÿÿÿvk   €         BehaviorØÿÿÿ(¬Ú p¬Ú Ð¬Ú `­Ú ˆ­Ú ¨­Ú Ð­Ú ø­Ú     Øÿÿÿvk 2   ˜¬Ú      grouppolicyname ÈÿÿÿA l l o w W i n d o w s I n k W o r k s p a c e     Øÿÿÿvk `   ø¬Ú      grouppolicypath ˜ÿÿÿS o f t w a r e \ P o l i c i e s \ M i c r o s o f t \ W i n d o w s I n k W o r k s p a c e       Øÿÿÿvk	   €       txhighrange       àÿÿÿvk   €          lowrangeØÿÿÿvk   €       Z<mergealgorithm  Øÿÿÿvk
   €        policytype      àÿÿÿvk   €         value    ÿÿÿnk  ¡OUÕÞ¬Õ    ¸˜µ        ±Ú ÿÿÿÿ    ÿÿÿÿ™µ ÿÿÿÿT                      WindowsLogon    ÿÿÿnk  ¡OUÕÞ¬Õ    ®Ú         ÿÿÿÿÿÿÿÿ   0¯Ú ™µ ÿÿÿÿ        (   t          AllowAutomaticRestartSignOn     Ðÿÿÿvk    ¯Ú       admxMetadataDevice      èÿÿÿ01=     2=         àÿÿÿè®Ú P¯Ú p¯Ú ˜¯Ú À¯Ú ˜°Ú     àÿÿÿvk   €`         BehaviorØÿÿÿvk   €         mergealgorithm  Øÿÿÿvk
   €         policytype      Ðÿÿÿvk t    °Ú       RegKeyPathRedirect      ðÿÿÿÓÚ ¸ÓÚ     hbin °Ú                        ˆÿÿÿS o f t w a r e \ M i c r o s o f t \ W i n d o w s \ C u r r e n t V e r s i o n \ P o l i c i e s \ S y s t e m   Ðÿÿÿvk <   È°Ú       RegValueNameRedirect    ÀÿÿÿD i s a b l e A u t o m a t i c R e s t a r t S i g n O n   Àÿÿÿlh x®Ú ‰é¤ËH±Ú Ä­Z/ˆ³Ú \ß™öàµÚ MrD(¸Ú 6Ñj¨ºÚ –”ð¼Ú k*¼Eÿÿÿnk  ¡OUÕÞ¬Õ    ®Ú         ÿÿÿÿÿÿÿÿ   X²Ú ™µ ÿÿÿÿ        $   t          ConfigAutomaticRestartSignOn    Ðÿÿÿvk e   è±Ú       admxMetadataDevice      ÿÿÿ07NE'   ConfigAutomaticRestartSignOnDescription@   AutomaticRestartSignOnConfig56=      56=               èÿÿÿ¸±Ú p²Ú ²Ú ¸²Ú à²Ú àÿÿÿvk   €`         BehaviorØÿÿÿvk   €         mergealgorithm  Øÿÿÿvk
   €         policytype      Ðÿÿÿvk t   ³Ú       RegKeyPathRedirect      ˆÿÿÿS o f t w a r e \ M i c r o s o f t \ W i n d o w s \ C u r r e n t V e r s i o n \ P o l i c i e s \ S y s t e m   ˆÿÿÿnk  ¡OUÕÞ¬Õ    ®Ú         ÿÿÿÿÿÿÿÿ   H´Ú ™µ ÿÿÿÿ        (   V       !   DisableLockScreenAppNotifications       Ðÿÿÿvk    0´Ú       admxMetadataDevice      èÿÿÿ01=    2=          àÿÿÿ ´Ú h´Ú ˆ´Ú °´Ú Ø´Ú hµÚ     àÿÿÿvk   €`         BehaviorØÿÿÿvk   €         mergealgorithm  Øÿÿÿvk
   €         policytype      Ðÿÿÿvk V   µÚ       RegKeyPathRedirect       ÿÿÿS o f t w a r e \ P o l i c i e s \ M i c r o s o f t \ W i n d o w s \ S y s t e m         Ðÿÿÿvk D   ˜µÚ       RegValueNameRedirect    ¸ÿÿÿD i s a b l e L o c k S c r e e n A p p N o t i f i c a t i o n s   ÿÿÿnk  ¡OUÕÞ¬Õ    ®Ú         ÿÿÿÿÿÿÿÿ   ˜¶Ú ™µ ÿÿÿÿ        (   V          DontDisplayNetworkSelectionUI   Ðÿÿÿvk    €¶Ú       admxMetadataDevice      èÿÿÿ01=    2=          àÿÿÿP¶Ú ¸¶Ú Ø¶Ú  ·Ú (·Ú ¸·Ú     àÿÿÿvk   €`       ò BehaviorØÿÿÿvk   €         mergealgorithm  Øÿÿÿvk
   €         policytype      Ðÿÿÿvk V   X·Ú       RegKeyPathRedirect       ÿÿÿS o f t w a r e \ P o l i c i e s \ M i c r o s o f t \ W i n d o w s \ S y s t e m         Ðÿÿÿvk <   è·Ú       RegValueNameRedirect    ÀÿÿÿD o n t D i s p l a y N e t w o r k S e l e c t i o n U I   ÿÿÿnk  ¡OUÕÞ¬Õ    ®Ú         ÿÿÿÿÿÿÿÿ   ¸¸Ú ™µ ÿÿÿÿ        (   t          EnableFirstLogonAnimation       àÿÿÿvk   €!         BehaviorØÿÿÿ˜¸Ú à¸Ú ¹Ú (¹Ú P¹Ú x¹Ú  ºÚ ˆºÚ     Øÿÿÿv